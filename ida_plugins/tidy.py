import re
import idc
import idaapi
import idautils
import ida_auto
import ida_name
import ida_bytes
import ida_name
import ida_bytes
import ida_funcs
import ida_idaapi
import ida_dirtree

function_dir = ida_dirtree.get_std_dirtree(ida_dirtree.DIRTREE_FUNCS)

class Function(object):
    REGEX_NAME_CHE = r'\<[^<>]*\>'
    REGEX_NAME_PAR = r'\((.*?)\)$'
    DEMANGLE_FLAGS = ida_name.MNG_SHORT_FORM | ida_name.MNG_NOBASEDT | ida_name.MNG_NOCALLC | ida_name.MNG_NOCSVOL

    def __init__(self, ea):
        self._func = ida_funcs.get_func(ea)
        self.address = ea
        self.orig_name = ida_funcs.get_func_name(ea)
        self.name = self._clean_name(self.address, self.orig_name)

    def _clean_name(self, ea, name):
        new_name = ida_name.get_demangled_name(ea, Function.DEMANGLE_FLAGS, ida_idaapi.get_inf_structure().demnames, idc.GN_STRICT)
        if not new_name:
            new_name = name
        nb_rep = 1
        while nb_rep:
            (new_name, nb_rep) = re.subn(Function.REGEX_NAME_CHE, '', new_name)
        self.proto = self._get_proto(new_name)
        new_name = re.sub(Function.REGEX_NAME_PAR, '', new_name)
        new_name = new_name.replace('\'', '').replace('`', '')
        new_name = new_name.strip().rstrip()
        return new_name

    def _get_proto(self, s):
        result = set()
        for start in range(len(s)):
            string = s[start:]
            result.update(re.findall('\(.*?\)', string))
        if not result:
            return ''
        f = list(filter(lambda s: True if s != '()' else False, result))
        for r in result:
            if len(r) > len(f):
                f = r
        return f

class FunctionTree(object):
    def __init__(self):
        self.black_list = ('std', '??$')
        self.delimiter = '::'
        self.tree = {}
        self.funcs = {}
        self.count = 0
        self._build_tree()
    
    def _add_func(self, func_name, node, func):
        spl = func_name.split(self.delimiter)
        if not spl:
            return
        name = spl.pop(0)
        if not spl:
            node[func.orig_name] = func
            self.count += 1
            return
        if name not in node:
            node[name] = {}
        return self._add_func(self.delimiter.join(spl), node[name], func)
    
    def _build_tree(self):
        for func_ea in idautils.Functions():
            func = Function(func_ea)
            if not func.name:
                continue
            self._add_func(func.name, self.tree, func)

class Tidy(object):
    def __init__(self):
        tree = FunctionTree().tree
        self._create_folders(tree)

    def _generate_paths(self, tree, pre=None):
        pre = [] if not pre else pre
        for k, v in tree.items():
            if isinstance(v, dict):
                yield from self._generate_paths(v, pre + [k])
            elif isinstance(v, Function):
                yield (pre + [k], v)

    def _create_folders(self, tree):
        for path, func in self._generate_paths(tree):
            function_name = path.pop()
            if ida_bytes.has_dummy_name(ida_bytes.get_flags(func.address)):
                path = ['subs'] + path
            elif not path and func.name.lower().startswith('__imp_load'):
                path = ['__imp_load']
            if not path:
                continue
            directory = '/'.join(path)
            for i in range(len(path)):
                p = '/'.join(path[0:i+1])
                if not function_dir.isdir(p):
                    function_dir.mkdir(p)
            if directory and not function_dir.isdir(directory):
                function_dir.mkdir(directory)
            function_dir.rename(function_name, '%s/%s' % (directory, function_name))
        

class TidyPlugin(ida_idaapi.plugin_t):
    flags = ida_idaapi.PLUGIN_KEEP
    comment = 'This plugin automates the organization of functions by categorizing them into folders based on their respective C++ namespaces and classes.'
    help = ''
    wanted_name = 'Tidy'
    wanted_hotkey = 'Alt-Shift-T'

    @staticmethod
    def init():
        return ida_idaapi.PLUGIN_KEEP

    @staticmethod
    def run(arg=0):
        if not ida_auto.auto_is_ok():
            idaapi.warning('Wait for the initial autoanalysis to finish.')
            return
        Tidy()

    @staticmethod
    def term():
        pass

def PLUGIN_ENTRY():
    return TidyPlugin()